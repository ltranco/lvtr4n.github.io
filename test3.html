<!DOCTYPE html>
<meta charset="utf-8">
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

var width = 960,
    height = 500,
    τ = 2 * Math.PI; // http://tauday.com/tau-manifesto

// An arc function with all values bound except the endAngle. So, to compute an
// SVG path string for a given angle, we pass an object with an endAngle
// property to the `arc` function, and it will return the corresponding string.
var arc = d3.svg.arc()
    .innerRadius(180)
    .outerRadius(240)
    .startAngle(0);

var arc2 = d3.svg.arc().innerRadius(100).outerRadius(150).startAngle(0);

// Create the SVG container, and apply a transform such that the origin is the
// center of the canvas. This way, we don't need to position arcs individually.
var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)
  .append("g")
    .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")")

// Add the background arc, from 0 to 100% (τ).
var background = svg.append("path")
    .datum({endAngle: τ})
    .style("fill", "#ddd")
    .attr("d", arc);

// Add the foreground arc in orange, currently showing 12.7%.
var foreground = svg.append("path")
    .datum({endAngle: .0 * τ, innerRadius: 100})
    .style("fill", "orange")
    .attr("d", arc2);

// Every so often, start a transition to a new random angle. Use transition.call
// (identical to selection.call) so that we can encapsulate the logic for
// tweening the arc in a separate function below.

  foreground.transition()
      .duration(5000)
      .call(arcTween, 4.14, 120, 130);


var drawArc = d3.svg.arc()
      .innerRadius(function(d, i, o) {
        return i;
      })
      .outerRadius(function(d, i, o) {
        return o;
      })
      .startAngle(0)
      .endAngle(function(d, i, o) {
        return d;
      });

function arcTween(transition, newAngle, innerRad, outerRad) {
  transition.attrTween("d", function(d) {
    var interpolate = d3.interpolate(d.endAngle, newAngle);
    return function(t) {
      return drawArc(interpolate(t), innerRad, outerRad);
    };
  });
}

</script>
